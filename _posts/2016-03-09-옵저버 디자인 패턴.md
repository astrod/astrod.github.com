---
layout: post
title: "옵저버(strategy) 디자인 패턴"
tags:
- designPattern
---
# 들어가며
이 글에 나오는 내용은 헤드 퍼스트 디자인 패턴에서 나오는 내용을 정리한 것이다.

# 어플리케이션의 요구사항
- 실제 기상 정보를 수집하는 장비가 존재함
- WeatherData 객체(기상 스테이션으로부터 오는 데이터를 추적하는 객체)
- 현재 기상 조건을 보여주는 디스플레이

이하 세 가지 요소로 이루어져 있다.
습도센서, 온도센서, 압력센서를 통해 기상 스테이션으로 정보가 축적되고, 기상 스테이션으로부터 WeatherData가 데이터를 가져오고, 그 데이터를 디스플레이 장비가 하면에 표시한다.

WeatherData 객체를 사용하여 현재 조건, 기상 통계, 기상 예측 이렇게 세 항목을 디스플레이 장비에서 데이터를 갱신하면서 보여주어야 한다.

## WeatherData Spec

~~~java
class WeatherData {
	getTemperature() // 측정된 온도
	getHumidity()  // 측정된 습도
	getPressure() // 측정된 기압
	public void measurementsChanged() {
		// 우리가 구현해야 할 부분. 기상 관측값이 갱신될 때마다 화면에게 데이터를 전달해주어야 			한다.
	}
}
~~~

확실하게 제공된 스펙은 다음과 같다.
- WeatherData 클래스에는 온도, 습도, 기압을 받아올 수 있는 메서드가 존재한다.
- 새로운 기상 관측 데이터가 전달될 때마다 measurementsChanged() 메소드가 호출된다.
- 기상 데이터를 사용하는 세 디스플레이의 항목을 구현해야 한다. 하나는 현재 조건을 표시하는 것이고, 다른 하나는 기상 통계를 표시하는 것이고, 나머지 하나는 기상 예보를 표시하는 것이다. 새로운 측정값이 들어올때마다 새로운 디스플레이를 갱신해야 한다.
- 시스템이 확장 가능해야 한다. 별도의 디스플레이 화면을 구성할 수 있어야 하고, 사용자들이 애플리케이션에 마음대로 디스플레이 항목을 추가/제거할 수 있어야 한다.

## 이렇게 한번 해볼까?

~~~ java
public class WeatherData {
	public void measurementsChanged() {
			float temp = getTemperature();
			float humidity = getHumidity();
			float pressure = getPressure();
			
			currentConditionsDisplay.update(temp, humidity, pressure);
			statisticsDisplay.update(temp, humidity, pressure);
			forecastDisplay.update(temp, humidity, pressure);
	}
}
~~~

이 코드는 구체적인 디스플레이 대상을 지정하여 업데이트를 하고 있기 때문에, 위에서 말한 네 번째 스펙인 **시스템이 확장 가능해야 한다**라는 조건을 충족시키지 못하고 있다. 디스플레이의 구현체에 업데이트를 시행하고 있기 때문이다.

## 그렇다면 옵저버 패턴이란?
- subject 객체가 데이터를 관리한다. 
- subject의 데이터가 달라지면 옵저버에게 그 소식이 전해진다. 
- 옵저버 객체는 subject객체를 구독하고 있으며, subject의 데이터가 바뀌게 되면 갱신 내용을 전달받게 된다.

즉 옵저버 패턴이란 다음과 같다.

**옵저버 패턴에서는 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고, 자동으로 내용이 갱신되는 방식으로 일대 다(one-to-many)의존성을 정의한다.**

## 구체적인 코드로는?

~~~ java
interface Subject {
	registerObserver();
	removeObserver();
	notifyObservers();
}

class ConcreteSubject implements Subject {
	registerObserver() {
		// 구현체
	}
	removeObserver() {
		// 구현체
	}
	notifyObservers() {
		// 구현체
	}
	// subject 클래스는 상태를 설정하고 알아내기 위한 세터, 개터 메소드가 존재할수도 있다.
	getState() 
	setState()
}

interface Observer {
	update()
}

class ConcreteObserver implements Observer {
	update() {
		// 옵저버가 데이터를 전송받는 메서드
	}
}

~~~

## 이와 같은 구조의 장점은?
- subject와 observer는 느슨한 결합(Loose Coupling)이다. subject가 옵저버에 대해 아는 것은 한 가지 밖에 없다 : 옵저버들은 Observer 인터페이스를 구현하고 있다는 것. 즉 옵저버의 구상 클래스가 무엇인지, 옵저버가 무엇을 하는지에 대해서 알 필요가 없다.

- 옵저버는 언제든지 새로 추가될 수 있다. subject는 Observer 인터페이스를 구현하는 객체의 목록만 디펜전시하고 있기 때문에, 언제든지 새로운 옵저버를 추가할 수 있다. 마찬가지로 언제든지 옵저버를 제거할 수 있다.

- Subject에 어떠한 코드도 추가하지 않고 옵저버를 추가할 수 있다.
- Subject와 Observer는 서로 독립적으로 재사용할 수 있다.
- Subject나 Observer가 바뀌더라도 서로에게 영향을 미치지 않는다.

여기서 디자인 패턴의 원칙 중 한 가지를 발견할 수 있다.

**서로 상호작용을 하는 개체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.**

객체끼리 서로 잘 모른다. Loose Coupling 전략을 취하는 것은 이와 같은 이점이 있다.

## 실제 코드로 나타내보자

~~~ java
public interface Subject {
	public void registerObserver(Observer o);
	public void removeObserver(Observer o);
	public void notifyObservers();
}

public interface Observer {
	public void update(float temp, float humidity, float pressure);
}

public interface DisplayElement {
	public void display();
}
~~~
이와 같은 인터페이스를 구성하고

~~~ java
public class WeatherData implements Subject {
	private List<Observer> observers;
	private float temperature;
	private float humidity;
	private float pressure;
	
	public WeatherData() {
		observers = new ArrayList<Observer>();
	}
	
	public void registerObserver(Observer o) {
		observers.add(o);
	}
	
	public void removeObserver(Observer o) {
		int i = observers.indexOf(o);
		if(i >= 0) {
			observers.remove(i);
		}
	}
	
	public void notifyObservers() {
		for(int i = 0; i<observers.length; i++) {
			observers.get(i).update(temperature, humidity, pressure);
		}
	}
	
	public void measurementsChanged() {
		notifyObservers();
	}
	
	public void setMeasurements(float temp, float humi, float pressure) {
		this.temperature = temp;
		this.humidity = humi;
		this.pressure = pressure;
		measurementsChanged();
	}
}
~~~

이와 같이 옵저버는 옵저버 인터페이스를 구현하고, 서브젝트는 서브젝트 인터페이스를 구현하고 서브젝트는 자신을 구독하는 옵저버의 리스트를 인스턴스 변수로 가지는 형태로 구현될 것이다.

옵저버를 구현하는 화면 객체는 Observer의 update() 함수를 내부에서 구현해야 할 것이다.

## 자바 자체적으로 지원하는 객체
옵저버 객체는 자바 내에서도 자체적으로 지원하고 있다. java.util 패키지 안에 Observer 인터페이스와 Obserable 클래스가 있다. 또한 이걸 사용하면, 푸시 방식으로도 갱신할 수 있고 풀 방식으로도 갱신이 가능하다.

Observable 클래스는 위의 Subject와 같은 역할을 하고, Observer인터페이스는 위의 옵저버 인터페이스와 같은 역할을 한다.

Subject 객체는 인터페이스를 구현하는 대신에 Observable 클래스를 상속받아서 작업을 진행하면 된다. 자신을 구독하는 객체들에게 연락을 할 때는

1) setChanged() 메소드를 호출하여 상태가 변경되었음을 알린다.
2) notifyObservers() 혹은 notifyObservers(Object arg) 중 하나를 호출한다. 파라미터로 넘어가는 값은, 구독하는 객체들에게 전달할 값이다.

연락을 받는 객체들은 update(Observable o, Object arg) 를 구현한다. 서브젝트 객체와 notify를 할 때 전달한 값이 파라미터로 넘어오게 된다.




