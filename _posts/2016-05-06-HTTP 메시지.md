---
title: "HTTP 메시지"
tags:
- http
---

# 들어가며
이 포스팅에 나오는 내용은 HTTP 완벽 가이드 3장, HTTP 메시지에 나오는 내용을 요약한 것입니다.

# 개요
이 포스팅에서 다루는 내용은 다음과 같다.

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작점, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

# 메시지의 흐름
HTTP 메시지는 어플리케이션 간에 주고받는 데이터의 블록들이다. 이 데이터는 다음과 같이 구성되어 있다.

- 텍스트 메타 정보
- 데이터(선택적으로 올 수 있다)

간단하게 용어를 정리하면 다음과 같다

- 인바운드 : 메시지가 원 서버로 향하는 것 
- 아웃바운드 : 메시지가 사용자 에이전트 방향으로 향하는 것

또한 메시지는 다운스트림으로 흐른다.

# 메시지의 각 부분
메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다. 시작줄은 이것이 어떤 메시지인지 서술하며 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 본문은 아예 없을 수도 있다.

시작줄과 헤더는 그냥 줄 단위로 분리된 아스카 문자열이다. 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다. 이 문자열은 'CRLF'라고 쓴다. HTTP 명세에는 CRLF가 줄바꿈 문자열이지만, 견고한 애플리케이션이라면 그냥 개행 문자도 받아들일 수 있어야 한다.

엔티티 본문이나 메시지 본문은 단순히 선택적인 데이터 덩어리이다. 텍스트나 이진 문자를 포함할 수도 있고, 그냥 비어있을 수도 있다.

~~~
// 시작줄
HTTP/1.0 200 OK 
// 헤더
Content-type: text/plain 
Content-length: 19
// 본문
HI! I'm a message! 
~~~

헤더를 보면 본문에 대해 꽤 많은 정보를 알 수 있다. Content-type을 보면 본문이 무엇인지 알 수 있고, Content-length를 보면 본문의 크기를 알 수 있다.

## 메시지 문법
모든 HTTP 메시지는 요청 메시지와 응답 메시지로 구분되고, 기본적으로 구조는 같다.
요청 메시지의 형식은 다음과 같다.

~~~
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
~~~

응답 메시지의 형식은 다음과 같다.

~~~
<버전> <상태코드> <사유 구절>
<헤더>

<엔터티 본문>
~~~

그러니까 시작줄 문법이 다른 거 말고는 구조도 동일하다. 각 부분에 대한 설명은 다음과 같다.

### 메서드
클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다. 총 여덣 가지가 있다.

### 요청 URL
요청 대상이 되는 리소스를 지칭하는 완전한 URL혹은 URL의 경로 구성요소다.

### 버전
이 메시지에서 사용하는 HTTP의 버전이다. 형식은 다음과 같다.

> HTTP/<메이저>.<마이너>

메이저와 마이너는 모두 정수이다.

### 상태 코드
요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자다. 각 코드의 첫 번째 자릿수는 상태의 일반적인 분류를 나타내며, 2XX는 성공, 3XX는 리다이렉트, 4XX는 클라이언트 에러, 5XX는 서버에러를 나타낸다.

### 사유 구절
숫자가 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구로, 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다. 사유 구절은 오로지 사람에게 읽히기 위한 용도이며, HTTP/1.0 200 NOT OK와 HTTP/1.0 200 OK는 서로 달라 보이지만 동등하게 성공을 의미하는 것으로 처리되어야 한다.

### 헤더들
이름, 콜론, 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들. 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.

### 엔터티 본문
엔터티 본문은 임의의 데이터 블록을 포함한다. 모든 메시지가 엔터티 본문을 갖는 것은 아니므로, 때때로 메시지는 그냥 CRLF로 끝나게 된다. 간단한 가상 요청과 응답 예제는 다음과 같다.

~~~
GET /test/hi-there.txt HTTP/1.1 // 시작줄
Accept: text/* // 헤더
HOST:www.joes-hardware.com
~~~

~~~
HTTP/1.0 200 OK // 시작줄
Content-type: text/plain // 헤더
Content-legnth: 19

Hi! I'm a message // 본문
~~~

## 시작줄
모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야 할 지 말해준다.

### 메서드
요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다. 예를 들면, 'GET /specials/saw-blade.gif HTTP/1.0'이라는 줄에서 메서드는 GET이다.


메서드 | 설명 						| 메시지 본문이 있는가?
-----|------------------------|----------------
GET  |서버에서 어떤 문서를 가져온다 		|없음
HEAD |서버에서 어떤 문서에 대한 헤더만 가져온다 | 없음
POST |서버가 처리해야 할 데이터를 보낸다 | 있음
PUT  |서버에 요청 메시지의 본문을 저장한다 | 있음
TRACE | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 | 없음
OPTION | 서버가 어떤 메서드를 수행할 수 있는지 확인한다 | 없음
DELETE | 서버에서 문서를 제거한다 | 없음
		
### 상태 코드
메서드가 서버에게 무엇을 해야 하는지 말해주는 것처럼, 상태 코드는 클라이언트에게 무슨 일이 일어났는지 말해준다. 상태코드는 응답의 시작줄에 위치한다. 예를 들어, 'HTTP/1.0 200 OK'에서 상태 코드는 200이다.

상태 코드의 종류는 다음과 같다.

전체 범위 | 정의된 범위 | 분류
-------|---------|---------
100 - 199 | 100 - 101 | 정보
200 - 299 | 200 - 206 | 성공
300 - 399 | 300 - 305 | 리다이렉션
400 - 499 | 400 - 415 | 클라이언트 에러
500 -599 | 500 - 505 | 서버 에러


만약에 정의된 범위를 넘어서는 상태 코드를 받는다면, 앞 자리를 확인하고 이것이 어떤 에러인지 확인할 수 있다. 예를 들면, 상태코드 515를 받는다면 이것이 5로 시작하므로 서버 에러임을 알 수 있다. 가장 흔한 코드 몇 가지를 설명하자면 다음과 같다.

상태 코드 | 사유 구절 | 의미
-------|-------|-------
200		| OK		| 성공! 요청한 모든 데이터는 응답 본문에 들어있다.
401	    | Unauthorized | 사용자 이름과 비밀번호를 입력해야 한다.
404		| Not Found | 서버는 요청한 URL에 해당하는 리소스를 찾지 못했다.

### 사유 구절
사유 구절은 응답 시작줄의 마지막 구성요소이다. 명세에 엄격하게 정의되어 있지는 않다.

## 헤더
HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 기본적으로 key / value 이다.

### 헤더 분류
HTTP 헤더 명세는 여러 필드를 정의한다. 애플리케이션은 또한 자유롭게 자신만의 헤더를 만들어 낼 수 있다. HTTP 헤더는 다음과 같이 분류된다.

### 일반 헤더
요청과 응답 양쪽에 모두 나타날 수 있음

### 요청 헤더
요청에 대한 부가 정보를 제공

### 응답 헤더
응답에 대한 부가 정보를 제공

### Entity 헤더
본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술

### 확장 헤더
명세에 정의되지 않은 새로운 헤더

헤더의 예는 다음과 같다.

~~~
Date: Tue, 3 Oct 1997 02:16:03 GMT // 서버가 응답을 만들어 낸 시간
Content-length: 15040 // 15,040 바이트의 데이터를 포함한 엔터티 본문
Content-type: image/gif
Accept: image/gif, image/jpeg, text/html
~~~

## 엔터티 본문
HTTP 요청이 전달하는 데이터이다. 여러 종류의 디지털 데이터를 실어 나를 수 있다.
