---
layout: post
title: "[자바 병렬 프로그래밍] 객체 공유"
tags:
- book
- java
category:
- book
---

* toc
{:toc}

# 개요
이 포스팅의 내용은 <<자바 병렬 프로그래밍>> 의 3장 객체 공유 챕터를 요약한 내용입니다.

# 객체 공유
이번 장에서는 여러 개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객체를 공유하고 공개하는 바법을 살펴본다.
소스 코드의 특정 블록을 동기화시키고자 할 때, 항상 메모리 가시성 문제가 발생하게 된다. 즉, 특정 변수의 값을 사용하고 있을 때 다른 스레드가 해당 변수의 값을 사용하지 못하도록 막아야 할 뿐만 아니라, 값을 사용한 다음 동기화 블록을 빠져나가고 나면 다른 스레드가 변경된 값을 즉시 사용할 수 있게 해야 한다.

## 가시성
특정 값을 변수에 쓴 다음에, 그 값을 다시 읽으면 이전에 저장해뒀던 바로 그 값을 가져오게 된다. 대부분 이런 경우가 정상적이지만, 멀티스레드 환경에서는 그렇지 않을 수 있다.

~~~java
public class NoVisibility {
	private static boolean ready;
	private static int number;
	
	private static class ReaderThread extends Thread {
		public void run() {
			while(!ready) Thread.yield();
			
			System.out.println(number);
		}
	}
	
	public static void main(String [] args) {
		new ReaderThread().start();
		ready = true;
		number = 42;
	}
}
~~~

이 코드에서는 메인 스레드와 읽기 스레드가 동시에 ready 와 number 변수를 공유하고 있다. 읽기 스레드는 while 문을 돌면서 ready 가 true 가 될때까지 대기하고 있다가, true 가 되면 number 를 프린트한다.
메인 스레드에서는 number 와 ready 의 값을 변경한다.

자연스럽게 42가 출력될 거라고 예상할 수 있다. 그러나, 0이라는 값을 출력할 수도 있고 심지어 영원히 값을 출력하지 않을 수도 있다. 두 개의 스레드에서 변수를 공유하여 사용하고 있지만, 적절한 동기화 기법을 사용하지 않은 것이다.

이 현상은 흔히 재배치(reordering) 라고 하는 현상 때문에 발생한다. 재배치 현상은 특정 메소드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에서 기인하는 문제이다. 메인 스레드는 number > ready 순으로 값을 세팅하지만, 읽기 스레드 입장에서는 ready > number 순으로 세팅될 수도 있고, 심지어는 아예 변경된 값을 읽지 못할 수도 있다.

이 문제를 해결하려면 다음 방법을 사용해야 한다.

> 여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용한다


### 스테일 데이터
앞에 예제에서 발생하는 현상을 스테일(stale : 낡은) 데이터라고 한다. 즉, 읽기 스레드가 ready 변수의 값을 읽으려고 할 때 변수가 이미 최신 값이 아닌 것이다. 이 문제는 항상 발생하는 것도 아닌데, 즉 특정 스레드가 어떤 값을 사용할 때 그 값이 최신값일 수도 있고, 아닐수도 있다는 의미이다.

다음 예제로 확인해 보자

~~~java
@NotThreadSafe
public class MutableInteger {
	private int value;
	
	public int get() {
		return value;
	}
	public void set(int value) {
		this.value = value;
	}
}
~~~

위의 클래스에서도 value 라는 값을 get / set 에서 동시에 사용하고 있지만 동기화가 되어 있지 않다. 이는 스테일 현상을 발생시킬 수도 있는데, 특정 스레드가 set 메소드를 호출하고 다른 스레드가 get 메소드를 호출할 때, set 메소드에서 지정한 값을 읽어오지 못하는 것이다.

다음과 같이 코드를 수정하여야 한다. 

~~~java
@NotThreadSafe
public class MutableInteger {
	@GuardedBy("this") private int value;
	
	public synchronized int get() {
		return value;
	}
	public synchronized void set(int value) {
		this.value = value;
	}
}
~~~

이 때 set 메소드만 동기화 한다고 하면, get 메소드가 여전히 스테일 상황을 초래할 수 있다. 반드시 둘 다 동기화하여야 한다.

### 단일하지 않은 64비트 연산
위의 예제에서 확인해 볼 수 있듯이, 스테일 현상이 발생하더라도 아예 없는 값을 가져가는 것은 아니다. (오래된 값을 가져갈 수는 있지만) 그러나, 64비트를 사용하는 숫자형에 volatile 키워드를 사용하지 않을 때는 난대없는 값이 생길 수도 있다.

volatile 로 지정되지 않은 long 이나 double 형의 64비트 값은 메모리에 쓰거나 읽을 때 두 번의 32비트 연산을 사용할 수 있도록 허용하고 있다. 그래서, 다른 스레드에 동작할 때 이전 값과 최신 값에서 각각 32비트씩 읽어와서 아예 없는 값이 등장할 수도 있다.

### 락과 가시성
위의 문제를 막기 위해 synchronized 를 활용할 수 있다. A 라는 스레드가 synchronized 로 둘러싸인 코드에서 사용한 모든 값을, 같은 락을 사용하는 synchronized 로 둘러싸인 코드를 스레드 B가 실행할 때 안전하게 사용할 수 있다.

만약, synchronized 등으로 동기화하지 않으면 변수의 값을 제대로 읽어간다고 절대로 보장할 수 없다.
바꿔 말하면, 여러 스레드에서 사용하는 변수를 적당한 락으로 막아주지 않는다면, 스테일 상태에 쉽게 빠질 수 있다.

### volatile 변수

자바 언어에서는 volatile 변수로 약간 동기화 기능을 제공할 수 있다. 다시 말에, volatile 로 선언된 변수의 값을 바꿨을 때 다른 변수에서 항상 최신값을 읽어갈 수 있게 해준다.

만약 특정 변수를 선언할 때 volatile 로 선언한다면, 컴파일러와 런타임 모두 '이 변수는 공유해 사용하므로 실행 순서를 재배치해서는 안 된다' 라고 이해한다. 이 변수는 프로세서의 레지스터에도, 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해 둔 최신의 값을 읽을 수 있다.
예제를 살펴보자.

~~~java
volatile boolean asleep;
// ...
    while(!asleep) countSomeSheep();
~~~

위의 코드는 특정 변수의 값을 확인해 반복문을 빠져나갈 상황인지 확인하는 예이다. 만약 위의 변수를 volatile 로 선언하지 않는다면, 다른 스레드가 asleep 의 값을 변경하였을 때 변경되었다는 상태를 확인하지 못할 수도 있다.

메모리 가시성의 입장에서 보면, volatile 변수를 사용하는 것은 synchronized 블록에 진입하는 것과 비슷한 상태에 해당한다. 하지만 그렇다고 해서, volatile 변수에 너무 의존하는 것은 좋지 않다. 이 변수만 사용하여 메모리 가시성을 확보하도록 작성한 코드는 synchronized 로 직접 동기화한 코드보다 훨씬 읽기 어렵고, 따라서 오류가 발생할 가능성도 높다.

일반적으로 volatile 변수는 위의 예제처럼 작업을 완료했다거나, 인터럽트가 걸리거나, 기타 상태를 보관하는 플래그 변수에 volatile 키워드를 지정한다. 

정리하면 다음과 같다.

> 락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있다. 하지만 volatile 변수는 연산의 단일성을 보장하지 못하고 가시성만 보장한다.

volatile 이와 같은 상황에만 사용하면 좋다.

- 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나, 해당 변수의 값을 변경하는 스레드가 하나만 존재
- 해당 변수가 불변조건과 관련되어 있지 않다.
- 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없다.


## 공개와 유출

특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개(published) 되었다고 한다. 

- 스코프 밖의 코드에서 볼 수 있는 변수에 스코프 내부의 객체에 대한 참조를 저장한다.
- private 이 아닌 메소드에서 호출한 메소드가 스코프 내부의 객체에 대한 참조를 저장한다. 
- private 가 아닌 메소드에서 호출한 메소드가 내부에서 생성한 객체를 리턴한다.
- 다른 클래스의 메소드로 객체를 넘겨준다.

위와 같은 상황이 발생하면, 객체가 공개되었다고 할 수 있다.  