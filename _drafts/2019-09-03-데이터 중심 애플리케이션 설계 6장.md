---
layout: post
title: "데이터 중심 애플리케이션 설계 6장 - 파티셔닝.md"
tags:
- data
- book
category:
- data
---
* toc
{:toc}

# 파티셔닝

복제와 달리, 파티셔닝은 데이터를 여러 파티션으로 쪼갤 때 사용하는 용어이다. 이 작업을 **샤딩**이라고 하기도 한다. 몽고 DB, 엘라스틱서치, 솔라클라우드에서는 샤드라고 부르고, Hbase 에서는 리전, 빅테이블에서는 태블릿, 카산드라와 리악에서는 브이로그라고 부른다. 하지만 파티션이 좀 더 일반적인 용어이므로 파티션을 사용하도록 하겠다.

데이터 파티셔닝을 통하여 다음과 같은 이점을 얻을 수 있다.

1. 대용량 데이터셋을 여러 디스크에 분산시킬 수 있다. 이를 통하여 질의 부하를 여러 프로세스로 분산시킬 수 있다.
2. 각 노드에서 쿼리를 처리할 수 있으므로, 질의 처리량을 늘리기 위해 노드를 추가할 수 있다.

# 파티셔닝과 복제
파티셔닝과 복제를 동시에 적용할 수 있다.

![partitionAndReplication]({{ site.url }}/asset/DS-6-1.png)

이 경우에는 복제의 모든 특성이 적용된다. 즉, 복제와 파티셔닝은 서로 연관이 없다.

# 키-값 데이터 파티셔닝

파티셔닝의 핵심은 **데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것** 이다. 파티셔닝이 고르게 이루어지지 않아 하나의 노드가 요청을 더 많이 받는 것을 쏠렸다(skewed) 고 한다. 데이터가 쏠리게 되면 파티셔닝의 효과가 매우 떨어진다. 이렇게 불균형하게 부하가 높은 파티션을 **핫스팟** 이라 한다.

핫스팟을 피하기 위한 가장 간단한 방법은 **레코드를 할당할 노드를 무작위로 선택하는 것** 이다. 그러나 커다란 단점이 있다. 어떤 파티션에서 데이터를 읽어야 하는지 알 수 없게 되는 것이다. 즉, 모든 노드에 병렬적으로 질의하여야 한다.

더 좋은 방법이 있다. 

## 키 범위 기준 파티셔닝
이 방법은 종이 백과사전처럼 각 파티션에 연속된 범위의 키를 할당하는 것이다. 각 범위 사이의 경계를 알면, 키가 어떤 파티션에 속하는지 쉽게 확인할 수 있다.

예를 들면
 
[Ark - Bell] > 파티션 1
[Bike - Cake] > 파티션 2

처럼 파티션을 분할하는 것이다. 키 범위 기준 파티셔닝에는 다음과 같은 특징이 있다.

1. 키의 범위가 항상 동일할 필요는 없다. 데이터가 고르게 분포하지 않았을 수 있기 때문이다.
2. 파티션 경계는 관리자가 수동으로 선택하거나, 데이터베이스에서 자동으로 선택할 수 있다.
3. 각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다(SS 테이블이나 LSM 트리처럼)
    - 그러나 키를 통하여 분할하는 방식은 특정한 접근 패턴이 핫스팟을 유발할 수 있다. 타임스탬프를 기준으로 하루 단위로 파티션을 분할한다고 가정해 보자. 키를 정렬된 순서로 저장한다면 가장 마지막 파티션이 모든 요청 부하를 받게 될 것이다.

## 키의 해시값 기준 파티셔닝
데이터가 skewed 되어 핫스팟이 발생할 수 있기 때문에, 많은 분산 데이터스토어는 해시함수를 사용하여 키의 파티션을 결정한다. 해시함수를 사용하여 키를 결정하면, 입력 문자열의 유사성과는 관련 없이 결과물은 파티션에 균등하게 배분된다.

파티셔닝용 해시 함수는 보안이 강력할 필요가 없다. 카산드라와 몽고DB 는 MD5 를 사용한다. 키에 적합한 해시 함수를 구했다면, 각 파티션에 키의 범위 대신에 해시값 범위를 가지고 데이터를 파티셔닝하면 된다. 

![partitionWithHash]({{ site.url }}/asset/DS-6-3.png)

이 기법은 키를 파티션 사이에 균일하게 분산시키기에 좋다. 그러나 단점이 있는데, 해시함수를 사용하여 키를 결정하면 정렬된 키를 가지고 데이터를 쉽게 질의할 수 있는 장점을 잃어버리게 된다. 몽고DB 에서는 해시 기반 샤딩 모드를 키면, range query 가 모든 파티션에 전송된다. 

카산드라는 두 가지 파티셔닝 전략를 조합하여 사용한다. 카산드라에서 테이블을 생성할 때 여러 컬럼을 포함하는 복합 기본키를 지정할 수 있다. 키의 첫 부분에만 해싱을 적용해 파티션 결정에 사용하고, 남은 컬럼은 SS 테이블에서 데이터를 정렬하는 색인으로 사용한다. 따라서 복합키의 첫 번째 컬럼으로는 range query 로 질의할 수 없지만, 다른 키로는 범위 스캔을 효율적으로 활용할 수 있다.

## 쏠림 작업부하와 핫스팟 완화

극단적인 케이스를 가정해 보자 : **항상 동일한 키로 읽고 쓰는 경우**. 이 경우에는 하나의 파티션으로 읽기/쓰기 요청이 몰리게 된다. 이런 케이스는 없을 거 같지만 실제로는 존재한다. 수백만의 팔로워를 지닌 유명인이 SNS 에서 글을 작성하는 경우를 가정해 보자. 유명인이 실행한 작업 때문에 동일한 키에 막대한 양의 데이터를 기록해야 할 수 있다. (키는 아마도 유명인의 userId 나 사람들이 댓글을 다는 actionId 가 될 것이다.)

현재 데이터 시스템에서는 이를 보정하기 어려우므로 애플리케이션단에서 이를 보정하여야 한다. 요청이 많이 쏠리는 키를 발견하면, 그 키의 시작이나 끝에 임의의 숫자를 붙이는 것이다. 임의의 10진수 두 개만 붙이더라도, 키의 쓰기 작업을 100개의 키로 분산시킬 수 있다.

다만 이렇게 하면 읽기 작업이 어려워진다. 100개의 키를 읽어서 데이터를 조립하여야 하기 때문이다. 이 방법은 요청이 몰리는 소수의 키에만 적용하는 것이 타당하다.

# 파티셔닝과 보조 색인 