---
title: "JVM"
tags:
- jvm
---

# 들어가며
이 포스팅의 내용은 <<네이버를 만든 기술, 읽으면서 배운다 - 자바>> 에 나오는 JVM 관련 내용을 정리한 것입니다.

# JVM
자바 코드는 바이트 코드로 변환되어, JRE(java runtime environment)위에서 실행된다. 이 JRE에서 가장 중요한 요소는 자바 바이트코드를 해석하는 JVM이다. JRE는 자바 API와 JVM으로 구성되며, JVM의 역할을 자바 애플리케이션을 클래스 로드를 통해 읽어들여 자바 API로 실행하는 것이다.

## 가상 머신
자바는 WORA(write once run anywhere)를 구현하기 위해 물리적인 머신과 별개로 자바 가상 머신을 돌릴 수 있도록 설계했다. 그래서 하드웨어에서 JVM을 구현하면, 하드웨어의 스펙과 상관 없이 자바 바이트 코드를 실행시킬 수 있다.

## 특징

1. 스택 기반의 가상 머신
	- 인텔 x86이나 arm 아키텍쳐가 레지스터 기반으로 동작하는 데 비해, JVM은 스택 기반을 작동한다.
2. 심벌릭 레퍼런스
	- 기본 자료형을 제외한 모든 타입은 메모리 주소 기반의 레퍼런스가 아니라, 심벌릭 레퍼런스를 통해 참조한다.
3. 가비지 컬렉션
	- 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고, 가비지 컬랙션에 의해 자동으로 파괴된다.
4. 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장
	- 플랫폼에 관련 없이, 기본 자료형의 크기가 동일하다.
5. 네트워크 바이트 순서
	- 네트워크를 통해 데이터를 전송하는 바이트 순서인 네트워크 바이트 순서를 사용한다. 네트워크 바이트 순서는 빅 엔디안이다.

## JVM 구조
자바로 작성한 코드는, 클래스 로더가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드하고, 실행 엔진이 자바 바이트코드를 실행한다.

- .java > (javac를 통해 컴파일) > .class > 클래스 로더에 로드 > 실행 엔진이 자바 바이트 코드를 실행

이런 식으로 자바 코드가 실행된다. 

## 클래스 로더
자바는 컴파일 타임이 아니라 런타임에 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더이다. 자바 클래스 로더의 특징은 다음과 같다.

- 계층 구조 : 클래스 로더끼리 부모 - 자식 관계를 이루어 계층 구조로 생성된다. 최상위 클래스 로더는 부트스트랩 클래스 로더이다.
- 위임 모델 : 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 작동한다. 클래스를 로딩할 때 먼저 상위 클래스 로더를 확인하여, 상위 클래스 로더에 있다면 해당 클래스를 사용하고, 없다면 로드를 요청받은 클래스 로더가 클래스를 로드한다.
- 가시성 제한 : 하위 클래스 로더는 상위 클래스 로더의 클래스를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더의 클래스를 찾을 수 없다.
- 언로드 불가 : 클래스 로더는 클래스를 로드할 수 있지만, 언로드할 수는 없다. 언로드 대신에 혀재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성할 수 있다.
	
클래스 로더가 클래스 로드를 요청받으면 클래스 로더 캐시 > 상위 클래스 로더 > 자기 자신의 순서로 해당 클래스가 있는지 확인한다.

클래스 로더가 아직 로드되지 않은 클래스를 찾으면 다음 그림과 같은 과정을 거쳐 클래스를 로드하고 링크하고 초기화한다.

로드 > 검증 > 준비 > 분석 > 초기화

- 로드 : 클래스를 파일에서 가져와 JVM의 메모리에 로드한다.
- 검증 : 읽어들인 클래스가 자바 언어 명세 및 JVM명세에 맞춰 잘 구현되었는지 확인한다.
- 준비 : 클래스가 필요로 하는 메모리를 할당하고, 정의된 필드, 메서드, 인터페이스를 나타내는 데이터 구조를 준비한다.
- 분석 : 클래스의 상수 풀 내 모든 심벌릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
- 초기화 : 클래스 변수를 적절한 값으로 초기화한다.

## 런타임 데이터 영역
런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 여섯 개의 영역으로 나눌 수 있다.

스레드마다 있는 영역 : PC 레지스터, JVM 스택, 네이티브 메서드 스택 <br>
모든 스레드가 공유하는 영역 : 힙, 메서드 영역, 런타임 상수

- PC 레지스터 : PC(program counter) 레지스터는 각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 생성된다. PC 레지스터에는 현재 실행 중인 JVM 명령의 주소가 저장된다.
- JVM 스택 : JVM 스택은 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. 스택 프레임이라는 구조체를 저장하는 스택으로, push, pop 작업만 실행한다. 예외 발생 시 printStackTrace() 등의 메서드로 보여주는 스택 트레이스 각각 한 라인이, 스택 프레임이다.
- 스택 프레임 : JVM 내에서 메서드가 실행될 때마다, 하나의 스택 프레임이 생성되 해당 스레드의 JVM 스택에 추가되고, 메서드가 종료되면 제거된다. 각 스택 프레임은 지역 변수 배열, 피연산자 스택, 현재 실행 중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다.

