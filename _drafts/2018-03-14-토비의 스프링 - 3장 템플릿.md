---
layout: post
title: "토비의 스프링 - 3장 템플릿"
tags:
- book
- java
category:
- book
---

* toc
{:toc}

# 템플릿
확장에는 자유롭게 열려 있고, 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙(OCP)를 생각해 보자. 이 원칙은 코드에서 어떤 부분은 변경을 통해
그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있음을 알려준다.

템플릿이란 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며, 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터
독립시킴으로서 효과적으로 활용할 수 있도록 하는 방법이다.

예제를 통해 살펴보도록 하자

## 다시 보는 초난감 DAO
UserDao 에는 아직 문제점이 남아 있다. 예외사항 처리에 대한 문제다.

### 예외처리 기능을 갖춘 DAO

~~~java
public void deleteAll() throws SQLException {
    Connection c = dataSource.getConnection();

    // 아래 두 라인에서 에러가 발생하면, 바로 메소드 실행이 중지된다.
    PreparedStatement ps = c.prepareStatement("delete from users");
    ps.executeUpdate();

    ps.close();
    c.close();
}
~~~

위의 두 라인에서 예외가 발생하면, 메소드를 바로 빠저나가게 된다. 이렇게 되면 ps와 c가 close() 되지 않아서, 리소스가 반환되지 않는 문제가 발생할 수 있다.
일반적으로 DB는 제한된 개수의 커넥션을 만들어서 재사용 가능한 풀을 만든다. 이를 커넥션 풀이라고 하는데, 커넥션이 제대로 반환되지 않는다면 커넥션이 모자라 문제가 발생할 수 있다.

그래서 JDBC 에서는 가져온 리소스를 항상 반환하기 위해 다음과 같은 코드를 권장하고 있다.

~~~java
public void deleteAll() throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = dataSource.getConnection();
        ps = c.prepareStatement("delete from users");
        ps.executeUpdate();
    } catch(SQLException e) {
        throw e;
    } finally {
        if(ps != null) { // 리소스 반환을 시도한다.
            try { // 반환 도중에 에러가 발생할 수 있으므로 try - catch 로 묶어준다.
                ps.close();
            } catch (SQLException e) {
            }
        }

        if(c != null) {
            try {
                c.close();
            } catch (SQLException e) {

            }
        }
    }
}
~~~

prepareStatement 나 connection 을 반환할때도 에러가 날 수 있기 때문에, try - catch 문으로 예외처리를 진행해주면 좋다.
마찬가지로, 조회를 위한 코드에도 비슷한 반환 처리를 진행해주면 된다.

## 변하는 것과 변하지 않는 것
그러나, 아쉬운 부분이 있다.

### JDBC try/catch/finally 코드의 문제점

1. 복잡한 try/catch/finally 블록이 2중으로 중첩이 되어 나오는데 그것이 모든 조회 메서드에 반복된다.
    - 하나라도 빼먹으면 나중에 어떤 부분을 빼먹었는지 찾기 어렵다. (응집도가 떨어진다)
    - 동일한 코드가 계속 반복된다.

### 분리와 재사용을 위한 디자인 패턴 적용
이제부터 변하는 부분과 변하지 않는 부분을 찾아낸 다음에, 변하는 부분을 변하지 않는 부분에서 분리하는 작업을 진행한다.

다음 코드를 보자

~~~java
Connection c = null;
PreparedStatement ps = null;

try {
    c = dataSource.getConnection();

    ps = c.preparedStatement("delete from users"); // 변하는 부분

    ...// 변하지 않는 부분
}
~~~

CRUD 쿼리를 실행하는 메소드라면 위의 구조에서 크게 달라지지 않는다. 만약에 add 메소드라면 변하는 부분을 다음과 같이 변경하면 된다.

~~~java
ps = c.preparedStatement("insert into users (id, name, password) values(?,?,?)");
ps.setString(1, user.getId());
ps.setString(2, user.getName());
ps.setString(3, user.getPassword());
~~~

그렇다면 변하는 부분을 변하지 않는 부분에서 분리할 방법을 찾으면, 변하지 않는 부분을 재사용할 수 있을 것이다.

#### 메소드 추출
먼저 생각해볼 수 있는 부분은 변하는 부분을 메소드로 추출하는 것이다.

~~~java
public void deleteAll() throws SQLException {
    try {
        c = dataSource.getConnection();
        ps = makeStatement(c);

        ps.executeUpdate();
    } catch(SQLException e) {
        // ...
    }
}

private PreparedStatement makeStatement(Connection c) throws SQLException {
    return c.preparedStatement("delete from user");
}
~~~

당장 보았을 때는 별 이득이 없어 보인다. 
왜냐면 method extract 를 사용할 시에는 분리한 메소드를 다른 곳에서 재사용할 수 있어야 하는데, 이건 반대로 분리시키고 남은 메소드가 재사용이 필요한 부분이고 분리된 메소드는 DAO 로직마다 새롭게 만들어야 하기 때문이다.
무언가 반대로 되었다.

#### 템플릿 메소드 패턴의 적용
다음은 템플릿 메소드 패턴을 이용하여 분리해보자. 템플릿 메소드 패턴은 상속을 통하여 기능을 확장하는 디자인 패턴이다. 변하지 않는 부분은 슈퍼클래스에 두고, 변하는 부분은 추상 메소드로 정의하여 서브클래스에서 오버라이드 하여 사용한다.

먼저, makeStatement() 메소드를 추상 메소드로 선언한다.

~~~java
abstract protected PreparedStatement makeStatement(Connection c) throws SQLException;
~~~

그리고 이를 상속하는 서브클래스를 만들어서 메소드를 구현한다.

~~~java
public class UserDaoDeleteAll extends UserDao {

    // 구현해야 하는 메소드를 구현한다.
    protected PreparedStatement makeStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("delete from users");
        return ps;
    }
}
~~~

이제 UserDao 의 기능을 확장하고 싶을 때마다, 상속을 통해 자유롭게 기능 확장이 가능하다. 확장 때문에 상위 DAO 에 영향을 주지 않기 때문에 OCP 를 그럴저럭 지키고 있다. 다만 몇 가지 문제가 있다.

1. DAO 로직마자 상속을 통해 새로운 클래스를 생성해야 한다.
2. 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다.
    - try/catch/finally 블록과 변하는 PreparedStatement 를 담고 있는 서브클래스가 클래스 레벨에서 컴파일 시점에 관계가 결정된다.
    - 관계의 유연성이 떨어진다.

위의 문제를 해결하기 위해, 전략 패턴을 도입하려고 한다.

#### 전략 패턴의 적용
OCP 를 잘 지키는 구조이면서 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이 전략 패턴이다. 전략 패턴은 오브젝트를 아예 둘로 분리하고, 클래스 레벨에서는 인터페이스를 통해 의존하도록 한다.
즉, 위에서 이야기했던 계속 변하는 부분을 다른 오브젝트로 분리하고 인터페이스를 통해 그 오브젝트를 사용하는 것이다.

예를 들면, deleteAll 메서드는 다음 로직을 따른다.

1. DB 커넥션 가져오기
2. PreparedStatement 를 만들어줄 외부 기능 호출하기
3. 전달받은 PreparedStatement 실행하기
4. 예외가 발생하면 다시 메소드 밖으로 던지기
5. 모든 경우에 PreparedStatement, Connection 을 적절히 닫아주기

2번인 PreparedStatement 를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 전력이다. 전략 패턴에 구조에 따라 이 기능을 인터페이스로 만들어 두고, 생성 전략을 호출하면 된다.
코드는 다음과 같다. 
 
~~~java
public interface StatementStrategy {
    PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
~~~

이 인터페이스를 상속하여, 실제로 전략을 생성할 수 있다.


~~~java
public class DeleteAllStatement implements StatementStrategy 
~~~


