---
layout: post
title: "토비의 스프링 - 2장 테스트"
tags:
- book
- java
category:
- book
---

* toc
{:toc}

# 테스트
스프링에서 가장 중요한 가치는 테스트라고 이야기하고 있다 스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술인데, 이런 복잡한 애플리케이션을 개발하는 데 필요한 기술 중 하나는 객체지향 기술이다. 그리고 나머지 하나의 기술을 테스트라고 이야기하고 있다.

> 스프링으로 개발을 하면서 테스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반을 포기하는 샘이다.

2장에서는 테스트란 무엇이며, 그 가치와 장점, 활용 전략, 스프링과의 관계를 살펴본다. 그리고 JUnit을 소개하고 이를 활용한 학습 전략 또한 살펴볼 것이다.

# UserDaoTest 다시 보기

## 테스트의 유용성
User 정보를 가져오는 UserDao가 있다고 가정하자. 이 코드는 main() 함수를 이용하여 userDao의 get() 메서드르 호출하고 결과를 화면에 출력하여 개발자가 눈으로 확인할 수 있게 해 준다.
만약에 이 코드를 책임에 따라 이리저리 분리하고 인터페이스를 도입하고, 오브젝트 팩토리를 통해 생성하게 하는 등의 리펙토링을 거쳤을 때 그것이 처음과 동일한 기능을 한다고 누가 보장할 수 있겠는가?

 > 테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

## UserDaoTest의 특징
~~~java
public static void main(String [] args) throws SQLException {
    ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

    Userdao dao = context.getBean("userDao", UserDao.class);

    User user = new User();
    user.setId("user");
    user.setName("백기선");
    user.setPassword("married");

    dao.add(user);

    System.out.println(user.getId() + " 등록 성공");

    User user2 = dao.get(user.getId());
    System.out.println(user2.getName());
    System.out.println(user2.getPassword());

    System.out.println(user2.getId() + " 조회 성공");
}
~~~

이 테스트는 다음과 같은 특징이 있다.

- 가장 손쉽게 시행 가능한 main() 메서드를 이용한다.
- 테스트의 대상인 UserDao의 오브젝트를 가져와 메서드를 호출한다.
- 테스트에 사용할 입력 값을 코드에서 직접 만들어 넣어준다.
- 테스트의 결과를 콘솔에 출력해준다.
- 각 단계의 작업이 에러 없이 끝나면, 콘솔에 성공 메시지로 출력해준다.

특징은 main() 메서드를 이용하여 쉽게 테스트를 수행하였다는 점과 테스트 대상인 UserDao를 직접 호출하였다는 것이다.


웹 프로그램에서 사용하는 DAO를 테스트하는 방법은 보통 다음과 같다.

1. 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다.
2. 테스트용 웹 어플리케이션을 서버에 배치한 후 웹 화면을 띄워 폼을 열고, 값을 입력한 후 버튼을 누른다.
3. 결과를 확인한다.

이는 흔히 사용하는 방법이지만, DAO를 테스트하는데는 단점이 너무 많다. 단점은 다음과 같다.

1. 모든 레이어의 기능을 다 구현한 뒤에야 테스트가 가능하다.
2. 다른 연결된 부분에서 문제가 발생하였을 확률이 있다.
    - DAO는 정상적으로 동작하지만, 웹에서 데이터를 입력받는 부분에서 문제가 생겼다.
    - SQL 문법이 틀렸다.


이를 피하기 위해, 테스트는 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중하여 테스트하는 것이 바람직하다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중하여 접근해야 한다.
이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(unit test)라고 한다.

- 일반적으로 단위는 작을수록 좋다.
- 통제할 수 없는 외부의 리소스에 의존하지 않는다.

또한 UserDaoTest는 main() 을 실행시키는 방법으로 테스트를 시행한다. 이는 좋은 방법이지만, 테스트 코드가 애플리케이션의 클래스 안에 있는 것보단 별도로 테스트용 코드를 만들어서 테스트 코드를 넣는게 좋다.
이렇게 테스트를 따로 클래스로 분리한 이후에는 자동으로 여러 번 테스트를 반복할 수 있다.

## UserDaoTest의 문제점

1. 수동 확인 작업의 번거로움
- 테스트 수행 과정과 입력 데이터 세팅은 모두 자동으로 진행하지만, 여전히 사람의 눈으로 확인하는 과정이 필요하다.

2. 실행 작업의 번거로움
main() 함수가 수백개가 되고 main 메서드도 많이 만들어지면 실행후 결과를 종합하여 눈으로 확인하는 과정이 어려워진다.

# UserDaoTest 개선

## 테스트 검증의 자동화
테스트 결과의 검증부분을 자동화할 수 있다. 먼저, 테스트의 결과에 대해 생각해보면 성공 / 실패 두 가지가 있다. 실패는 또한 테스트가 진행되는 동안에 에러가 발생하는 것과 결과가 예상했던 값과 다른 경우가 있다.
이를 고려하여 테스트 검증 부분을 추가하자.

~~~java
if (!user.getName().equals(user2.getName())) {
    System.out.println("테스트 실패 (name)");
} else if(!user.getPassword().equals(user2.getPassword())) {
    System.out.println("테스트 실패 (password)");
} else {
    System.out.println("조회 테스트 성공");
}
~~~

## 테스트의 효율적인 수행과 결과 관리
이제 main() 메서드로 만든 테스트는 필요한 기능은 모두 갖추었다. 그러나 좀 더 편리하게 테스트를 수행하고 결과를 확인하려면 테스트 프레임워크를 사용하는 것이 좋다. 자바에서는 JUnit 이라는 테스트 지원 도구를 활용한다.

### Junit 테스트로 전환
JUnit은 프레임워크다. 프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아 주도적으로 애플리케이션의 흐름을 제어한다. 따라서 테스트로 전환하려면 먼저 main 메서드의 테스트 코드를 일반 메서드로 옮겨야 한다.
새로 만든 테스트 코드는 두 가지를 따라야 한다. 하나는 public 으로 선언되어야 하고 하나는 @Test 애노테이션이 붙어야 한다.

~~~java
public class UserDaoTest {
    @Test
    public void addAndGet() throws SQLException {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

        UserDao dao = context.getBean("userDao", UserDao.class);

        // implementation
    }
}
~~~

원래 검증 코드는 다음과 같았다.

~~~java
if (!user.getName().equals(user2.getName())) {
 System.out.println("테스트 실패 (name)");
} else if(!user.getPassword().equals(user2.getPassword())) {
 System.out.println("테스트 실패 (password)");
} else {
 System.out.println("조회 테스트 성공");
}
~~~

JUnit 에서 사용하는 도구로 다음과 같이 변경할 수 있다.

~~~java
assertThat(user2.getPassword(), is(user.getPassword()));
~~~

# 개발자를 위한 테스팅 프레임워크 JUnit
JUnit은 자바의 표준 테스팅 프레임워크라고 이야기 할 만큼 폭넓게 사용되고 있다. 스프링의 테스팅 모듈도 JUnit을 활용하고 있다. JUnit은 단순하기 때문에 빠르게 작성할 수 있고 IDE 단에서 테스트를 손쉽게 실행할 수 있는 여러 부기 기능도 제공한다.

또한 빌드 툴(Maven, ANT) 에서도 플러그인이나 테스크를 이용하여 손쉽게 JUnit 테스트를 실행할 수 있다.

## 테스트 결과의 일관성
지금까지 JUnit을 활용하여 깔끔한 테스트 코드를 만들었고 편리하게 실행할 수 있는 방법도 확인하였다. 그러나 다음과 같은 문제가 아직 남아있다. 위의 테스트는 DB내에 어떤 값이 존재하냐에 따라 결과가 다르게 나올 수 있다는 점이다.

앞에서 단위 테스트의 조건을 살펴보았다. 단위 테스트는 다음과 같은 조건을 만족하여야 한다.

- 일반적으로 단위는 작을수록 좋다.
- 통제할 수 없는 외부의 리소스에 의존하지 않는다.

DB라는 리소스에 의존하여 테스트 결과가 다르게 나오면 안 된다.

> 코드의 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

UserDaoTest는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있다는 문제가 있다. 가장 좋은 방법은 addAndGet() 테스트를 마치고 나면 사용자 정보를 삭제하여 테스트를 수행하기 이전 상태로 만들어주는 것이다.

### deleteAll()과 getCount() 추가

위의 조건을 만족하기 위해 처음으로 해야 할 일은 deleteAll() 메서드를 UserDAO에 추가하는 것이다. deleteAll() 은 USER 테이블의 모든 레코드를 삭제하는 기능이 있다.

~~~java
public void deleteAll() throws SQLException {
    Connection c = dataSource.getConnection();

    PreparedStatement ps = c.prepareStatement("delete from users");

    ps.executeUpdate();

    ps.close();
    c.close();
}
~~~

다음은 getCount() 메서드를 추가한다. 이 메서드는 USER 테이블의 레코드 개수를 돌려준다.

~~~java
public int getCount() throws SQLEception {
    Connection c = dataSource.getConnection();

    PreparedStatement ps = c.prepareStatement("select count(*) from users");

    ResultSet rs = ps.executeQuery();
    rs.next();
    int count = rs.getInt(1);

    rs.close();
    ps.close();
    c.close();

    return count;
}
~~~

### deleteAll()과 getCount()의 테스트
새로운 기능을 추가하였으니 테스트를 만들어야 한다. 그러나 두 기능은 테스트를 만들기 애매하다. 굳이 테스트를 하자면 USER 테이블에 데이터를 넣고 삭제하는 테스트를 만들어야 하는데, 이는 개발자가 직접 수행해야 하는 테스트라서 번거롭다.

그래서, 새로운 테스트를 만들기 보다는 기존에 만든 addAndGet() 테스트를 확장하는 방법을 사용하는 편이 더 낫다.
addAndGet() 테스트의 불편한 점은 실행 전에 수동으로 USER 테이블의 모든 데이터를 삭제해야 한다는 점이니, 이 메소드를 테스트 시작 전에 호출하여 데이터를 모두 삭제해주면 된다.

그러나 deleteAll() 메서드 자체도 검증되지 않았다는 문제점이 있다. 그래서 getCount()를 함께 적용한다. deleteAll()이 정상적으로 적용되었다면, 메서드 호출 후에 getCount()를 호출하면 0을 반환하여야 한다.
그러면 getCount() 는 어떻게 올바르게 동작한다고 증명할 것인가? 이는 getCount() 만의 테스트 코드를 작성하면 된다.

정리하면 다음과 같다.

1. addAndGet()
    - deleteAll()
    - getCount()
    - 잔여 테스트 진행

2. getCount()
    - add 후에 1이 나오는지 확인

테스트 코드는 다음과 같다

~~~java
@Test
public void addAndGet() throws SQLException() {
    dao.deleteAll(); // 전체 삭제
    assertThat(dao.getCount(), is(0));

    User user = new User();
    user.setId("gyumee");
    user.setName("박성철");
    user.setPassword("springno1");

    dao.add(user);
    assertThat(dao.getCount(), is(1));
}
~~~

위와 같이 테스트를 작성하면, 어떤 상황에서 반복적으로 실행된다고 하더라도 동일한 결과가 나온다.

> 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안 된다. DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

### 포괄적인 테스트

위에서는 getCount()에 대해 테스트를 작성하지 않았으니, getCount() 에 대해 좀 더 꼼꼼하게 테스트를 만들어 보자. 시나리오는 다음과 같다.

1. USER 테이블의 데이터를 모두 지운다.
2. getCount() 가 0 임을 확인한다.
3. user를 insert 한다
4. getCount() 가 증가함을 확인한다.

~~~java
dao.deleteAl();
assertThat(dao.getCount(), is(0));
dao.add(user1);
assertThat(dao.getCount(), is(1));
dao.add(user2);
assertThat(dao.getCount(), is(2));
dao.add(user3);
assertThat(dao.getCount(), is(3));
~~~

주의해야 할 점은 JUnit이 테스트의 실행 순서를 보장해주지 않는다는 것이다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.

